#!/usr/bin/env python3
"""
Command-line interface for vulnerability prediction
Usage: python predict_vulnerability.py [options]
"""

import argparse
import sys
import os
from pathlib import Path

# Add src to path
sys.path.append('src')

from src.inference.predict_vulnerabilities import VulnerabilityPredictor
from torch_geometric.data import Data
import torch


def main():
    parser = argparse.ArgumentParser(description='Predict vulnerabilities using trained GNN model')
    
    parser.add_argument('--model', '-m', 
                       default='models/final_model.pth',
                       help='Path to trained model file (default: models/final_model.pth)')
    
    parser.add_argument('--w2v', '-w',
                       default='data/w2v/w2v.model', 
                       help='Path to Word2Vec model (default: data/w2v/w2v.model)')
    
    parser.add_argument('--demo', '-d',
                       action='store_true',
                       help='Run demo with synthetic data')
    
    parser.add_argument('--test', '-t',
                       action='store_true', 
                       help='Test predictor with real data from input folder')
    
    args = parser.parse_args()
    
    print("="*80)
    print("VULNERABILITY PREDICTION CLI")
    print("="*80)
    
    try:
        # Initialize predictor
        predictor = VulnerabilityPredictor(
            model_path=args.model,
            w2v_path=args.w2v
        )
        
        if args.demo:
            print("\nüéÆ Running demo mode...")
            run_demo(predictor)
            
        elif args.test:
            print("\nüß™ Running test mode...")
            run_test(predictor)
            
        else:
            print("\nüí° Usage examples:")
            print("  Demo mode:     python predict_vulnerability.py --demo")
            print("  Test mode:     python predict_vulnerability.py --test")
            print("  Custom model:  python predict_vulnerability.py --model path/to/model.pth --demo")
            
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)


def run_demo(predictor):
    """Run demo with synthetic graph data"""
    
    print("Creating synthetic vulnerability examples...")
    
    # Example 1: "Safe" code pattern
    print("\n" + "="*60)
    print("EXAMPLE 1: SAFE CODE PATTERN")
    print("="*60)
    
    safe_graph = create_safe_graph_pattern()
    result1 = predictor.predict(safe_graph)
    predictor.print_prediction(result1, "Safe Code Pattern")
    
    # Example 2: "Vulnerable" code pattern  
    print("\n" + "="*60)
    print("EXAMPLE 2: VULNERABLE CODE PATTERN")
    print("="*60)
    
    vuln_graph = create_vulnerable_graph_pattern()
    result2 = predictor.predict(vuln_graph)
    predictor.print_prediction(result2, "Vulnerable Code Pattern")
    
    # Summary
    print("\n" + "="*60)
    print("DEMO SUMMARY")
    print("="*60)
    print(f"Safe pattern prediction:       {result1['prediction_details']['predicted_class']} ({result1['confidence']:.1%})")
    print(f"Vulnerable pattern prediction: {result2['prediction_details']['predicted_class']} ({result2['confidence']:.1%})")
    print("\n‚úÖ Demo completed!")


def run_test(predictor):
    """Test with real data from input folder"""
    
    input_path = Path("data/input")
    
    if not input_path.exists():
        print(f"‚ùå Input folder not found: {input_path}")
        return
    
    # Look for pickle files
    pkl_files = list(input_path.glob("*.pkl"))
    
    if not pkl_files:
        print(f"‚ùå No .pkl files found in {input_path}")
        return
    
    print(f"üìÅ Found {len(pkl_files)} input files")
    
    # Load first file as example
    import pandas as pd
    
    test_file = pkl_files[0]
    print(f"üìÑ Loading test data from: {test_file.name}")
    
    try:
        df = pd.read_pickle(test_file)
        print(f"‚úÖ Loaded {len(df)} samples")
        
        # Test on first few samples
        test_samples = min(5, len(df))
        print(f"üß™ Testing on first {test_samples} samples...")
        
        results = []
        for i in range(test_samples):
            sample = df.iloc[i]
            graph_data = sample['input']
            true_label = sample['target']
            
            result = predictor.predict(graph_data)
            result['true_label'] = int(true_label)
            result['sample_id'] = i
            results.append(result)
            
            # Print result
            true_status = "Vulnerable" if true_label else "Safe"
            pred_status = "Vulnerable" if result['is_vulnerable'] else "Safe"
            correct = "‚úÖ" if result['is_vulnerable'] == true_label else "‚ùå"
            
            print(f"\nSample {i}: {correct}")
            print(f"  True:      {true_status}")
            print(f"  Predicted: {pred_status} ({result['confidence']:.1%})")
        
        # Calculate accuracy
        correct_predictions = sum(1 for r in results if r['is_vulnerable'] == r['true_label'])
        accuracy = correct_predictions / len(results)
        
        print(f"\nüìä Test Results:")
        print(f"  Samples tested: {len(results)}")
        print(f"  Correct predictions: {correct_predictions}")
        print(f"  Accuracy: {accuracy:.1%}")
        
    except Exception as e:
        print(f"‚ùå Error testing with real data: {e}")


def create_safe_graph_pattern():
    """Create a graph pattern that should be predicted as safe"""
    # Simple linear structure (typical of safe, straightforward code)
    num_nodes = 8
    x = torch.randn(num_nodes, 100) * 0.5  # Smaller variance for "normal" patterns
    
    # Linear chain structure
    edges = [[i, i+1] for i in range(num_nodes-1)]
    edges += [[i+1, i] for i in range(num_nodes-1)]  # Bidirectional
    
    edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
    return Data(x=x, edge_index=edge_index)


def create_vulnerable_graph_pattern():
    """Create a graph pattern that should be predicted as vulnerable"""
    # Complex structure with many connections (typical of vulnerable code)
    num_nodes = 12
    x = torch.randn(num_nodes, 100) * 1.2  # Higher variance for "complex" patterns
    
    # Create a more complex graph with cycles and multiple connections
    edges = []
    
    # Base chain
    for i in range(num_nodes-1):
        edges.extend([[i, i+1], [i+1, i]])
    
    # Add complex interconnections (simulating complex control flow)
    edges.extend([
        [0, 5], [5, 0],    # Jump connections
        [2, 8], [8, 2],    # Cross connections
        [3, 9], [9, 3],    # More complexity
        [1, 7], [7, 1],
        [4, 10], [10, 4],
        [6, 11], [11, 6],
        [0, 11], [11, 0],  # Long-range connections
    ])
    
    edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
    return Data(x=x, edge_index=edge_index)


if __name__ == "__main__":
    main()